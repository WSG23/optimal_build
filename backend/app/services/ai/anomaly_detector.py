"""Phase 1.3: Smart Alerts & Anomaly Detection.

Monitors key metrics and generates alerts when anomalies are detected.
"""

from __future__ import annotations

import logging
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from datetime import datetime, timedelta
from enum import Enum
from typing import Any

from sqlalchemy import select, func, and_
from sqlalchemy.ext.asyncio import AsyncSession

from app.models.business_performance import (
    AgentDeal,
    DealStatus,
)
from app.models.property import MarketTransaction
from app.models.regulatory import AuthoritySubmission

logger = logging.getLogger(__name__)


class AlertPriority(str, Enum):
    """Priority levels for alerts."""

    LOW = "low"
    NORMAL = "normal"
    HIGH = "high"
    URGENT = "urgent"


class AlertCategory(str, Enum):
    """Categories of alerts."""

    MARKET = "market"
    PIPELINE = "pipeline"
    REGULATORY = "regulatory"
    FINANCIAL = "financial"
    PERFORMANCE = "performance"
    SYSTEM = "system"


@dataclass
class Alert:
    """An alert generated by the anomaly detection system."""

    id: str
    title: str
    message: str
    category: AlertCategory
    priority: AlertPriority
    entity_type: str | None = None
    entity_id: str | None = None
    data: dict[str, Any] = field(default_factory=dict)
    suggested_actions: list[str] = field(default_factory=list)
    created_at: datetime = field(default_factory=datetime.now)
    expires_at: datetime | None = None
    acknowledged: bool = False


class AlertRule(ABC):
    """Base class for alert detection rules."""

    name: str
    category: AlertCategory
    default_priority: AlertPriority
    check_interval_minutes: int = 60

    @abstractmethod
    async def check(
        self,
        db: AsyncSession,
        user_id: str,
        context: dict[str, Any],
    ) -> list[Alert]:
        """Check for alert conditions.

        Args:
            db: Database session
            user_id: User to check alerts for
            context: Additional context data

        Returns:
            List of alerts generated
        """
        pass


class AssumptionVsMarketRule(AlertRule):
    """Alert when deal assumptions deviate significantly from market."""

    name = "assumption_vs_market"
    category = AlertCategory.MARKET
    default_priority = AlertPriority.HIGH
    check_interval_minutes = 240  # Check every 4 hours

    async def check(
        self,
        db: AsyncSession,
        user_id: str,
        context: dict[str, Any],
    ) -> list[Alert]:
        """Check if any deal assumptions deviate from market averages."""
        alerts: list[Alert] = []

        # Get user's open deals
        deals_query = select(AgentDeal).where(
            and_(
                AgentDeal.agent_id == user_id,
                AgentDeal.status == DealStatus.OPEN,
            )
        )
        result = await db.execute(deals_query)
        deals = result.scalars().all()

        # Get recent market transactions for comparison
        six_months_ago = datetime.now() - timedelta(days=180)
        market_query = select(func.avg(MarketTransaction.psf_price).label("avg_psf")).where(
            MarketTransaction.transaction_date >= six_months_ago.date()
        )

        market_result = await db.execute(market_query)
        market_avg = market_result.scalar() or 0

        if market_avg == 0:
            return alerts

        # Check each deal's assumptions against market
        for deal in deals:
            deal_metadata = deal.metadata_json or {}
            assumed_psf = deal_metadata.get("assumed_psf")

            if assumed_psf:
                deviation = (assumed_psf - float(market_avg)) / float(market_avg) * 100

                if abs(deviation) > 15:  # More than 15% deviation
                    direction = "above" if deviation > 0 else "below"
                    alerts.append(
                        Alert(
                            id=f"assumption_market_{deal.id}",
                            title=f"Assumption Deviation: {deal.title}",
                            message=f"Your assumed PSF (${assumed_psf:,.0f}) is {abs(deviation):.1f}% {direction} the market average (${float(market_avg):,.0f})",
                            category=self.category,
                            priority=(
                                AlertPriority.HIGH if abs(deviation) > 25 else AlertPriority.NORMAL
                            ),
                            entity_type="deal",
                            entity_id=str(deal.id),
                            data={
                                "assumed_psf": assumed_psf,
                                "market_avg_psf": float(market_avg),
                                "deviation_percent": deviation,
                            },
                            suggested_actions=[
                                "Review your pricing assumptions",
                                "Check recent comparable transactions",
                                "Consider adjusting the offer price",
                            ],
                        )
                    )

        return alerts


class PipelineVelocityRule(AlertRule):
    """Alert when pipeline velocity changes significantly."""

    name = "pipeline_velocity"
    category = AlertCategory.PIPELINE
    default_priority = AlertPriority.NORMAL
    check_interval_minutes = 1440  # Check daily

    async def check(
        self,
        db: AsyncSession,
        user_id: str,
        context: dict[str, Any],
    ) -> list[Alert]:
        """Check for significant changes in pipeline metrics."""
        alerts = []

        now = datetime.now()
        this_month_start = now.replace(day=1, hour=0, minute=0, second=0, microsecond=0)
        last_month_start = (this_month_start - timedelta(days=1)).replace(day=1)

        # This month's pipeline value
        this_month_query = select(func.sum(AgentDeal.estimated_value_amount)).where(
            and_(
                AgentDeal.agent_id == user_id,
                AgentDeal.status == DealStatus.OPEN,
                AgentDeal.created_at >= this_month_start,
            )
        )
        this_month_result = await db.execute(this_month_query)
        this_month_value = float(this_month_result.scalar() or 0)

        # Last month's pipeline value
        last_month_query = select(func.sum(AgentDeal.estimated_value_amount)).where(
            and_(
                AgentDeal.agent_id == user_id,
                AgentDeal.status == DealStatus.OPEN,
                AgentDeal.created_at >= last_month_start,
                AgentDeal.created_at < this_month_start,
            )
        )
        last_month_result = await db.execute(last_month_query)
        last_month_value = float(last_month_result.scalar() or 0)

        if last_month_value > 0:
            change_percent = (this_month_value - last_month_value) / last_month_value * 100

            if change_percent < -20:
                alerts.append(
                    Alert(
                        id=f"pipeline_velocity_{user_id}_{now.strftime('%Y%m')}",
                        title="Pipeline Velocity Slowing",
                        message=f"Your pipeline value has dropped {abs(change_percent):.1f}% compared to last month",
                        category=self.category,
                        priority=(
                            AlertPriority.HIGH if change_percent < -30 else AlertPriority.NORMAL
                        ),
                        entity_type="pipeline",
                        entity_id=user_id,
                        data={
                            "this_month_value": this_month_value,
                            "last_month_value": last_month_value,
                            "change_percent": change_percent,
                        },
                        suggested_actions=[
                            "Review lead generation activities",
                            "Follow up on stalled deals",
                            "Consider expanding prospecting efforts",
                        ],
                    )
                )
            elif change_percent > 50:
                alerts.append(
                    Alert(
                        id=f"pipeline_growth_{user_id}_{now.strftime('%Y%m')}",
                        title="Strong Pipeline Growth",
                        message=f"Your pipeline value has increased {change_percent:.1f}% compared to last month!",
                        category=self.category,
                        priority=AlertPriority.LOW,
                        entity_type="pipeline",
                        entity_id=user_id,
                        data={
                            "this_month_value": this_month_value,
                            "last_month_value": last_month_value,
                            "change_percent": change_percent,
                        },
                        suggested_actions=[
                            "Prioritize high-value opportunities",
                            "Ensure adequate resources for deal management",
                        ],
                    )
                )

        return alerts


class RegulatoryDelayRule(AlertRule):
    """Alert when regulatory submissions are delayed."""

    name = "regulatory_delay"
    category = AlertCategory.REGULATORY
    default_priority = AlertPriority.HIGH
    check_interval_minutes = 720  # Check twice daily

    async def check(
        self,
        db: AsyncSession,
        user_id: str,
        context: dict[str, Any],
    ) -> list[Alert]:
        """Check for regulatory submissions that are overdue."""
        alerts = []

        # Get pending submissions older than 60 days
        cutoff_date = datetime.now() - timedelta(days=60)

        submissions_query = select(AuthoritySubmission).where(
            and_(
                AuthoritySubmission.submitted_at < cutoff_date,
                AuthoritySubmission.status.in_(["submitted", "in_review", "rfi"]),
            )
        )

        result = await db.execute(submissions_query)
        delayed_submissions = result.scalars().all()

        for submission in delayed_submissions:
            days_pending = (datetime.now() - submission.submitted_at).days

            alerts.append(
                Alert(
                    id=f"regulatory_delay_{submission.id}",
                    title=f"Regulatory Submission Delayed: {submission.reference_number}",
                    message=f"Submission has been pending for {days_pending} days (typical: 45 days)",
                    category=self.category,
                    priority=(AlertPriority.HIGH if days_pending > 90 else AlertPriority.NORMAL),
                    entity_type="regulatory_submission",
                    entity_id=str(submission.id),
                    data={
                        "reference_number": submission.reference_number,
                        "submission_type": submission.submission_type,
                        "days_pending": days_pending,
                        "submitted_at": submission.submitted_at.isoformat(),
                    },
                    suggested_actions=[
                        "Contact the regulatory agency for status update",
                        "Check if any RFI responses are outstanding",
                        "Review submission for completeness",
                    ],
                )
            )

        return alerts


class ComparableTransactionRule(AlertRule):
    """Alert when relevant comparable transactions occur."""

    name = "comparable_transaction"
    category = AlertCategory.MARKET
    default_priority = AlertPriority.NORMAL
    check_interval_minutes = 480  # Check 3 times daily

    async def check(
        self,
        db: AsyncSession,
        user_id: str,
        context: dict[str, Any],
    ) -> list[Alert]:
        """Check for new comparable transactions relevant to user's deals."""
        alerts = []

        # Get recent transactions (last 7 days)
        week_ago = datetime.now() - timedelta(days=7)

        recent_txns_query = (
            select(MarketTransaction)
            .where(MarketTransaction.transaction_date >= week_ago.date())
            .order_by(MarketTransaction.transaction_date.desc())
            .limit(10)
        )

        result = await db.execute(recent_txns_query)
        recent_transactions = result.scalars().all()

        # Get user's active deals for comparison
        deals_query = select(AgentDeal).where(
            and_(
                AgentDeal.agent_id == user_id,
                AgentDeal.status == DealStatus.OPEN,
            )
        )
        deals_result = await db.execute(deals_query)
        active_deals = deals_result.scalars().all()

        for txn in recent_transactions:
            for deal in active_deals:
                # Check if transaction is relevant (same asset type, nearby location)
                if deal.asset_type.value == txn.market_segment:
                    # Check price deviation
                    deal_metadata = deal.metadata_json or {}
                    deal_psf = deal_metadata.get("target_psf")

                    if deal_psf and txn.psf_price:
                        deviation = (float(txn.psf_price) - deal_psf) / deal_psf * 100

                        if abs(deviation) > 10:
                            direction = "above" if deviation > 0 else "below"
                            alerts.append(
                                Alert(
                                    id=f"comparable_txn_{txn.id}_{deal.id}",
                                    title="New Comparable Transaction",
                                    message=f"A similar property sold at ${float(txn.psf_price):,.0f} psf - {abs(deviation):.1f}% {direction} your target for {deal.title}",
                                    category=self.category,
                                    priority=AlertPriority.NORMAL,
                                    entity_type="transaction",
                                    entity_id=str(txn.id),
                                    data={
                                        "transaction_psf": float(txn.psf_price),
                                        "deal_target_psf": deal_psf,
                                        "deviation_percent": deviation,
                                        "deal_id": str(deal.id),
                                        "deal_title": deal.title,
                                    },
                                    suggested_actions=[
                                        "Review transaction details",
                                        "Adjust pricing strategy if needed",
                                        "Use as comparable in negotiations",
                                    ],
                                )
                            )
                            break  # One alert per transaction

        return alerts


class CashFlowDeviationRule(AlertRule):
    """Alert when actual cash flows deviate from projections."""

    name = "cash_flow_deviation"
    category = AlertCategory.FINANCIAL
    default_priority = AlertPriority.HIGH
    check_interval_minutes = 1440  # Check daily

    async def check(
        self,
        db: AsyncSession,
        user_id: str,
        context: dict[str, Any],
    ) -> list[Alert]:
        """Check for cash flow deviations in active projects."""
        # This would typically check against actual vs projected cash flows
        # Simplified implementation for now
        return []


class AnomalyDetectionService:
    """Service that monitors key metrics and generates alerts."""

    def __init__(self) -> None:
        """Initialize the anomaly detection service."""
        self.rules: list[AlertRule] = [
            AssumptionVsMarketRule(),
            PipelineVelocityRule(),
            RegulatoryDelayRule(),
            ComparableTransactionRule(),
            CashFlowDeviationRule(),
        ]

    async def run_detection_cycle(
        self,
        db: AsyncSession,
        user_id: str,
        context: dict[str, Any] | None = None,
    ) -> list[Alert]:
        """Run all detection rules and return generated alerts.

        Args:
            db: Database session
            user_id: User to run detection for
            context: Additional context data

        Returns:
            List of all alerts generated
        """
        context = context or {}
        all_alerts: list[Alert] = []

        for rule in self.rules:
            try:
                alerts = await rule.check(db, user_id, context)
                all_alerts.extend(alerts)
                logger.debug(f"Rule {rule.name} generated {len(alerts)} alerts")
            except Exception as e:
                logger.error(f"Error running rule {rule.name}: {e}")

        # Sort by priority (urgent first)
        priority_order = {
            AlertPriority.URGENT: 0,
            AlertPriority.HIGH: 1,
            AlertPriority.NORMAL: 2,
            AlertPriority.LOW: 3,
        }
        all_alerts.sort(key=lambda a: priority_order.get(a.priority, 99))

        return all_alerts

    async def get_alerts_for_user(
        self,
        db: AsyncSession,
        user_id: str,
        category: AlertCategory | None = None,
        priority: AlertPriority | None = None,
    ) -> list[Alert]:
        """Get filtered alerts for a user.

        Args:
            db: Database session
            user_id: User to get alerts for
            category: Optional category filter
            priority: Optional priority filter

        Returns:
            Filtered list of alerts
        """
        alerts = await self.run_detection_cycle(db, user_id, {})

        if category:
            alerts = [a for a in alerts if a.category == category]

        if priority:
            alerts = [a for a in alerts if a.priority == priority]

        return alerts


# Singleton instance
anomaly_detection_service = AnomalyDetectionService()
