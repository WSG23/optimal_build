'use strict';

const Fragment = Symbol.for('react.fragment');

const _contextRegistry = new Set();

function isArray(value) {
  return Array.isArray(value);
}

function flattenChildren(children) {
  const result = [];
  const stack = isArray(children) ? children : [children];
  for (const item of stack) {
    if (item === null || item === undefined || item === false) {
      continue;
    }
    if (isArray(item)) {
      result.push(...flattenChildren(item));
    } else {
      result.push(item);
    }
  }
  return result;
}

function createElement(type, props, ...rawChildren) {
  const normalizedProps = props ? { ...props } : {};
  const children = flattenChildren(rawChildren);
  if (children.length === 1) {
    normalizedProps.children = children[0];
  } else if (children.length > 1) {
    normalizedProps.children = children;
  }
  return { type, props: normalizedProps };
}

function cloneElement(element, props, ...children) {
  if (!isValidElement(element)) {
    throw new TypeError('Cannot clone an element that is not valid');
  }
  const mergedProps = { ...element.props, ...(props || {}) };
  const normalizedChildren = flattenChildren(children);
  if (normalizedChildren.length === 1) {
    mergedProps.children = normalizedChildren[0];
  } else if (normalizedChildren.length > 1) {
    mergedProps.children = normalizedChildren;
  }
  return { type: element.type, props: mergedProps };
}

function createContext(defaultValue) {
  const context = {
    _currentValue: defaultValue,
    Provider({ value, children }) {
      context._currentValue = value;
      return children ?? null;
    },
    Consumer({ children }) {
      if (typeof children === 'function') {
        return children(context._currentValue);
      }
      return children ?? null;
    },
  };
  _contextRegistry.add(context);
  return context;
}

function useContext(context) {
  if (!_contextRegistry.has(context)) {
    throw new Error('useContext called with value that is not a React context.');
  }
  return context._currentValue;
}

function isValidElement(value) {
  return Boolean(value) && typeof value === 'object' && 'type' in value && 'props' in value;
}

const Children = {
  map(children, fn) {
    return flattenChildren(children).map(fn);
  },
  forEach(children, fn) {
    flattenChildren(children).forEach(fn);
  },
  count(children) {
    return flattenChildren(children).length;
  },
  toArray(children) {
    return flattenChildren(children);
  },
  only(children) {
    const array = flattenChildren(children);
    if (array.length !== 1) {
      throw new Error('React.Children.only expected to receive a single React element child.');
    }
    return array[0];
  },
};

module.exports = {
  Children,
  Fragment,
  cloneElement,
  createElement,
  createContext,
  isValidElement,
  useContext,
  version: '18.3.1-stub',
  __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED: {
    flattenChildren,
    isArray,
  },
};
