const Fragment = Symbol.for('stub.react.fragment')

function createElement(type, props, ...children) {
  const normalizedChildren = []
  for (const child of children) {
    if (Array.isArray(child)) {
      normalizedChildren.push(...child)
    } else if (child !== undefined && child !== null) {
      normalizedChildren.push(child)
    }
  }
  return {
    type,
    props: {
      ...(props || {}),
      children: normalizedChildren.length === 0 ? props?.children ?? [] : normalizedChildren,
    },
  }
}

function useState(initialValue) {
  const value = typeof initialValue === 'function' ? initialValue() : initialValue
  const setValue = () => {}
  return [value, setValue]
}

function useRef(initialValue) {
  return { current: initialValue }
}

function useMemo(factory) {
  return factory()
}

function useCallback(callback) {
  return callback
}

function useEffect() {}

const contextStacks = new WeakMap()

function createContext(defaultValue) {
  const context = {
    defaultValue,
  }

  contextStacks.set(context, [defaultValue])

  function Provider({ value, children }) {
    const stack = contextStacks.get(context)
    stack.push(value)
    return {
      $$typeof: Provider,
      __context: context,
      props: { children },
    }
  }

  context.Provider = Provider
  return context
}

function pushContext(context, value) {
  const stack = contextStacks.get(context)
  stack.push(value)
}

function popContext(context) {
  const stack = contextStacks.get(context)
  stack.pop()
}

function getContextValue(context) {
  const stack = contextStacks.get(context)
  return stack[stack.length - 1]
}

function useContext(context) {
  return getContextValue(context)
}

module.exports = {
  Fragment,
  createContext,
  createElement,
  useState,
  useRef,
  useMemo,
  useEffect,
  useCallback,
  useContext,
  __internal: {
    pushContext,
    popContext,
    getContextValue,
  },
}
