# Phase 2B Visualisation Delivery Plan (v0.4)

This document lays out the path from the current JSON stub to a production-grade, scenario-aware 3D preview pipeline for developer feasibility. It supersedes the earlier stub-only note and should be treated as the working plan for Phase 2B visualisation work.

---

## Changelog

- **v0.4 (2025-11-04)** – Manual QA guardrails reinstated after preview payload builder delivery.
  - Documented the root cause: Phase 2B lacked a dedicated manual UI checklist, so agents skipped validating preview payloads in the test harness.
  - Added enforcement steps requiring every Phase 2B code change to execute the UI walkthrough in Section 10 and record outcomes before closing work.
  - Linked the work queue acceptance criteria to the new checklist so reviewers can block merges without the documented manual run.
- **v0.3 (2025-11-03)** – Process updated to allow Phase 2B execution in parallel with the infrastructure audit.
  - Added guardrails for coordination with audit coverage work and clarified dependency hand-offs.
  - Documented renderer bootstrap priorities for the new work queue item.
- **v0.2 (2025-10-22)** – Preview job model + synchronous generator implemented
  - Added `preview_jobs` table, service helpers, and API wiring so developer capture queues a preview job and records massing metadata. Response now includes `preview_job_id` and job status with polling-ready fields.
  - Frontend lists preview job status and stores the job id for future async polling; CLI documented for job orchestration (future renderer integration).

- **v0.1 (2025-10-22)** – Converted stub specification into an end-to-end delivery plan covering architecture, workflow, testing, and open decisions.

---

## 1. Objectives

- Deliver asynchronous preview generation that reflects asset-specific optimisation outputs (massing, heights, colour legend).
- Provide reliable status lifecycle (`queued → processing → ready/failed`) surfaced to the frontend and developer APIs.
- Support scenario-aware previews (base, expansion, reposition) without blocking core feasibility calls.
- Persist preview artefacts in durable storage with cache-friendly URLs and asset versioning.
- Instrument the pipeline (metrics, logs, alerts) so failed renders or stale assets are visible within existing monitoring.

### 1.1 Parallel Execution Guardrails

- Maintain weekly sync notes with the audit owner so renderer changes do not mask coverage regressions.
- Flag any shared dependencies (SQLAlchemy models, logging utilities) via the audit checklist before merging.
- Record integration risks in the work queue card to preserve visibility for the launch-readiness review.
- Keep renderer experiments behind feature flags until audit sign-off so the release branch stays green.

### 1.2 Manual UI QA Enforcement

- **Root cause:** Only Phase 1D deliverables had a manual UI checklist, so the Phase 2B preview payload builder shipped without anyone running the Web preview harness end-to-end. The missing guardrail meant agents relied solely on automated tests and never launched the renderer UI, leaving regressions invisible to the product owner.
- **Process fix:** Every Phase 2B change must execute the walkthrough in [Section 10](#10-manual-ui-qa-checklist-preview-payload-builder) before the task can be marked complete. The resulting notes (pass/fail + observations) must be committed alongside the change (e.g., appended to the PR description or work queue entry).
- **Enforcement:** Reviewers should reject Phase 2B merges lacking the manual UI results, and agents must block their own work until the checklist is filled out.

---

## 2. Current Stub Baseline

### 2.1 Backend Payload (already available)

`DeveloperVisualizationSummary` and `SiteAcquisitionResult.visualization` expose the following fields today:

| Field | Type | Description |
|-------|------|-------------|
| `status` | string | Preview status flag (`placeholder`, `processing`, `ready`, etc.). Currently hard-coded to `placeholder`. |
| `preview_available` | bool | `true` when a preview payload exists. The stub always returns `true`. |
| `notes` | array[str] | User-facing copy explaining the placeholder. |
| `concept_mesh_url` | string/null | Points to `/static/dev-previews/{property_id}.json` generated by `preview_generator.ensure_preview_asset`. |
| `camera_orbit_hint` | object/null | Suggested orbit parameters (theta/phi/radius) for the WebGL viewer. |
| `preview_seed` | int/null | Deterministic seed to keep placeholder geometry stable between runs. |
| `massing_layers` | array[object] | Per-asset massing slice (`asset_type`, `allocation_pct`, `gfa_sqm`, `nia_sqm`, `estimated_height_m`, `color`). |
| `color_legend` | array[object] | Colour legend entries for rendering UI overlays. |

### 2.2 Limitations

- Geometry is a simple extruded JSON without offsets, rotations, or facade detail.
- Preview is created synchronously during capture; long-running renders would block API responses.
- No persistence beyond flat files in `static/dev-previews/`; no asset versioning or expiry.
- Status is static; frontend cannot distinguish between “render queued” vs “render failed”.
- No observability (metrics/logs) beyond web-server logs.

---

## 3. Target Pipeline Architecture

### 3.1 Workflow Overview

```
Client triggers preview → API enqueues job → Prefect worker builds geometry payload →
Renderer service generates GLB + thumbnails → Assets uploaded to S3/static store →
Metadata updated in DB → Frontend polls status → Player streams rendered asset
```

### 3.2 Components

1. **Preview Request API** – FastAPI endpoint (`POST /api/v1/developers/{property_id}/previews`) to enqueue renders; reused during initial capture.
2. **Preview Job Store** – New table (`preview_jobs`) recording `job_id`, `property_id`, `scenario`, `status`, `asset_version`, `payload_checksum`, timestamps, and error info.
3. **Async Worker** – Prefect flow (e.g., `developer_preview_flow`) backed by CLI/queue runner to process jobs.
4. **Geometry Builder** – Extends `app/services/preview_generator.py` to emit parametric geometry (floor plates, podiums, podium setbacks) plus metadata for renderer.
5. **Renderer** – Headless service (Blender CLI or Three.js node script) converting geometry into GLB + preview PNG.
6. **Asset Store** – Local `static/dev-previews/` in dev; S3 bucket (`s3://optimal-build-previews/{env}/`) in production with per-version paths.
7. **Status Updater** – Service function to persist final URLs, update `DeveloperVisualizationSummary`, and notify interested parties (webhooks/Faye optional).
8. **Frontend Polling** – Hook that hits `GET /api/v1/developers/{property_id}/previews/{job_id}` or reuse existing capture endpoint to refresh status banner.

---

## 4. Backend Implementation Plan

### 4.1 API & Data Model

- Add `PreviewJob` SQLModel with fields: `id`, `property_id`, `scenario`, `status`, `requested_at`, `started_at`, `finished_at`, `asset_version`, `preview_url`, `thumbnail_url`, `payload_checksum`, `message`.
- Expose endpoints:
  - `POST /api/v1/developers/{property_id}/previews` → returns `job_id`, enqueues Prefect flow.
  - `GET /api/v1/developers/{property_id}/previews/{job_id}` → returns job status + asset URLs.
  - Extend existing capture response to include the latest `preview_job_id` and status (backwards compatible by defaulting to stub when none exists).
- Status states: `queued`, `processing`, `ready`, `failed`, `expired`.
  - `expired` indicates asset purged or version mismatch; triggers auto re-render.

### 4.2 Job Orchestration

- Create Prefect flow `developer_preview_flow` under `backend/flows/preview_generation.py`:
  1. Fetch job metadata + latest optimiser output (massing layers, scenarios).
  2. Call geometry builder to produce canonical payload (JSON + metadata).
  3. Invoke renderer via subprocess; guard with timeout configurable per environment.
  4. Upload assets; write asset manifest with checksum + version.
  5. Update job status and notify.
- Provide CLI wrapper `python -m scripts.preview pipeline --job <id>` mirroring Prefect flow for local runs.
- Integration with existing queue: reuse Prefect deployment/per-worker pattern documented in `docs/architecture.md`.

### 4.3 Geometry Builder Enhancements

- Move JSON creation logic from `ensure_preview_asset` into `build_preview_payload(property_id, massing_layers, *, site_boundary, terrain)` returning:
  - `layers` with translation/rotation/footprint polygon per asset type.
  - `scenarios` referencing base/expansion/reposition massings.
  - `metadata` including bounding box, centroid, camera hints.
- Preserve lightweight JSON stub for fallback (`ensure_preview_asset` now calls builder and stores minimal version).
- Optionally support unioned site polygons for accurate podium footprints; align with heritage constraints.

### 4.4 Renderer Service

- MVP renderer: Python module using `trimesh`/`pythreejs` or Node-based Three.js script.
- Inputs: geometry payload JSON, material palette, lighting config.
- Outputs: `*.glb` mesh, `*.png` thumbnail, optional `*.json` metadata for annotations.
- Configure headless execution through Docker image triggered by Prefect task.
- Timeout defaults: 90 s per render; fail gracefully with captured stderr.

### 4.5 Storage & Versioning

- Directory structure:
  ```
  static/dev-previews/{property_id}/{version}/preview.glb
  static/dev-previews/{property_id}/{version}/preview.json  # metadata
  static/dev-previews/{property_id}/{version}/thumbnail.png
  ```
- `version` = `{optimizer_version}-{preview_schema_version}-{YYYYMMDDHHMM}`.
- Upload helper abstracts between local filesystem and S3 (reuse `app.services.storage` if available, else introduce).
- Expire assets older than N versions (configurable, default keep last 3) and mark jobs as `expired` when pruned.

### 4.6 Notifications (Optional Phase 2B stretch)

- Allow webhook registration for preview completion; reuse existing event bus if available.
- Emit structured log to analytics/BI pipeline for audit.

---

## 5. Frontend Integration Plan

- Keep test-harness scope minimal per [`ui-status.md`](planning/ui-status.md); changes exist only to verify backend functionality.
- Site Acquisition and Feasibility UI subscribes to preview status:
  - On capture completion, call `POST` endpoint; show “rendering” banner.
  - Poll `GET` every 5 s (with exponential backoff) until status `ready` or `failed`.
  - When `ready`, load GLB in viewer, fall back to JSON stub if GLB missing.
  - When `failed`, surface error message with retry CTA (`POST` again).
- Update viewer components to accept `thumbnail_url` for loading placeholders.
- Add status chip to scenario tabs showing preview readiness per scenario (minimal styling, functional only).
- Frontend polls the new endpoints: `GET /api/v1/developers/properties/{property_id}/preview-jobs`, `GET /api/v1/developers/preview-jobs/{job_id}`, and `POST /api/v1/developers/preview-jobs/{job_id}/refresh` to surface async progress + reruns.
- Ensure UI gracefully handles browsers without WebGL 2 (fallback to existing stub).

---

## 6. Observability, Testing, and SLAs

- **Metrics** (`preview_generation.*`):
  - `jobs_created`, `jobs_succeeded`, `jobs_failed`, `duration_ms`, `render_time_ms`, `upload_time_ms`, `queue_depth`.
- **Logs**: structured JSON with `job_id`, `property_id`, `scenario`, `status`.
- **Alerts**: Pager/Slack when failure rate >10% in 10 min or median duration >5 min.
- **Testing**:
  - Unit: geometry builder (footprints, heights, alignment with optimiser outputs), renderer invocation (mocked subprocess), job status transitions.
  - Integration: end-to-end CLI test writing artefacts to temp dir; verify API surfaces URLs/status.
  - Contract: JSON schema for preview metadata, GLB validation via `assimp` or `trimesh` loader.
  - Performance: ensure average render <120 s for 10-layer massing; concurrency test with 5 simultaneous jobs.
- **SLA**: 95% of previews ready within 5 min; auto retry once on failure; manual retry command documented.

---

## 7. Timeline & Dependencies

| Week | Deliverable | Owner | Dependencies |
|------|-------------|-------|--------------|
| Week 1 | API + data model, CLI scaffolding, Prefect flow skeleton | Backend | Asset optimiser outputs stable schema |
| Week 2 | Geometry builder upgrade, renderer MVP, storage abstraction | Backend | Week 1 scaffolding |
| Week 3 | Frontend polling + viewer updates, observability wiring, QA sign-off | Frontend + Backend | Week 2 assets ready |
| Week 4 (buffer) | Performance tuning, optional notifications, production rollout checklist | Platform | Week 3 complete |

Dependencies: Phase 2B asset optimisers must emit per-scenario `massing_layers` with footprints; CLI/Prefect infrastructure must be deployed.

---

## 8. Outstanding Decisions

1. Renderer technology choice (Blender vs. custom Three.js vs. existing CAD service). **Owner:** Platform + Visualisation.
2. Where to source accurate footprints (do we derive from URA site boundary or external CAD uploads?). **Owner:** Geometry.
3. Asset retention policy (how long to keep historical previews, do we support version comparison?). **Owner:** Platform.
4. Authentication for asset URLs (public S3 with signed URLs vs. proxy). **Owner:** Security.
5. Do we support per-scenario renders (base/expansion/reposition) in one GLB or multiple files? **Owner:** Product.

---

## 9. Next Steps Checklist

- [ ] Finalise renderer selection + infrastructure requirements.
- [x] Draft `PreviewJob` model and migration script.
- [x] Implement job queue entry point and CLI trigger (`python -m scripts.heritage.pipeline` unchanged; preview jobs now flow through `/api/v1/developers/preview-jobs/...`).
- [x] Extend geometry builder to output schema needed by renderer.
- [x] Update frontend to consume new status lifecycle.
- [ ] Define monitoring dashboards and alerts.

## 10. Manual UI QA Checklist (Preview Payload Builder)

> **Mandatory for every Phase 2B change touching preview generation, renderer orchestration, or frontend consumption.** Agents must paste the completed checklist (with notes/screenshots) into the associated PR or work queue update.

### Environment Prep

- [ ] Backend running with latest preview payload changes: `JOB_QUEUE_BACKEND=inline uvicorn app.main:app --reload`
- [ ] Prefect worker (or inline CLI) seeded with a property that has optimiser outputs: `python -m scripts.preview enqueue --property-id <TEST_PROPERTY_ID>`
- [ ] Frontend dev server: `cd frontend && npm run dev`
- [ ] Browser at `http://localhost:3000/agents/developers/<TEST_PROPERTY_ID>/preview`

### Walkthrough Steps

1. **Trigger render:** From the Site Acquisition view, click **“Generate Preview”** (or run the CLI command) and confirm a job id appears in the developer console/logs.
   - [ ] Status banner transitions from `placeholder` → `processing` within the UI.
2. **Poll for completion:** Leave the page open until the status flips to `ready` (or `failed`).
   - [ ] Confirm the thumbnail placeholder updates to the new asset timestamp.
   - [ ] If `failed`, capture the error message surfaced in the UI.
3. **Inspect payload:** Use the UI “View JSON” affordance (or network tab) to download the generated payload.
   - [ ] Bounding box, layer counts, and camera hints match expectations from backend logs.
4. **Visual verification:** Rotate the preview in the test harness viewer.
   - [ ] Massing layers render with colours and heights matching the optimiser seed data.
5. **Regression capture:** Take a screenshot of the loaded preview (attach to PR if possible) and record any anomalies in `docs/development/testing/known-issues.md` if they are harness-specific.

### Exit Criteria

- [ ] Checklist completed with pass/fail notes.
- [ ] Screenshot and/or console logs attached to PR/work queue note.
- [ ] Any failures triaged (fixed immediately or documented with owner + follow-up task).
