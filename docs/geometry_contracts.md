# Geometry Contracts

The geometry helper modules define a lightweight graph used by the import, overlay
and export services to reason about building plans.  The data contracts described
in this document are intentionally implementation agnostic so they can be used by
Python workers, API services, or queued jobs that only need structured geometry
metadata.

## Entities

Each node derives from the `GeometryEntity` dataclass defined in
`app.core.models.geometry`.  Nodes share the following common attributes:

- `id` – unique identifier within the graph.
- `name` – optional human friendly label.
- `source` – optional [`SourceReference`](../backend/app/core/models/geometry.py)
  capturing the origin system and identifier (for example a CAD GUID).
- `metadata` – dictionary used for extensible attributes (classification,
  comments, tags, etc.).

Specialised subclasses add domain specific attributes:

- **Level** – floor plane with `elevation` (metres) and optional `height`.
- **Space** – enclosed region bound to a `level_id`, storing ordered `boundary`
  points and optional `wall_ids` used for adjacency.
- **Wall** – linear segment with `start`/`end` points, optional `thickness`,
  associated `level_id`, and optional `space_ids` that reference neighbouring
  spaces.
- **Door** – opening anchored to a `wall_id`, with `position` (metres along the
  wall), optional `width`, swing description, and optional `level_id`.
- **Fixture** – point asset (sprinkler, sink, riser, etc.) with `category`,
  `location`, and optional `level_id`.

Relationships between nodes are represented by the `Relationship` dataclass
(`type`, `source_id`, `target_id`, optional `attributes`).  Duplicate
relationships are merged by type and endpoints when inserted into a graph.

## Graph and Integrity Rules

`GeometryGraph` maintains collections for each entity type and an adjacency list
for relationships.  Utility methods ensure:

- identifiers are unique across entity categories (e.g. a space and door cannot
  share the same id),
- cross references resolve to existing nodes (`Space.level_id`, `Door.wall_id`,
  `Relationship.source_id`, etc.),
- relationships can be queried or removed by `(type, source_id, target_id)`.

The `GraphBuilder` helper enforces these rules while constructing a graph from
CAD/import payloads.  Calling `GraphBuilder.validate_integrity()` or using the
serializer helpers (see below) will raise a `ValueError` when an invalid
reference or duplicate identifier is detected.

## Serialization Contracts

`GeometrySerializer` orchestrates conversions between three representations:

1. **Parsed CAD payloads** – typically dictionaries where points are emitted as
   `{ "x": float, "y": float }`.  Use `GeometrySerializer.from_cad(payload)` to
   validate and convert to a `GeometryGraph`.
2. **Internal neutral format** – JSON friendly dictionaries produced by
   `GeometryGraph.to_dict()`.  This is the format stored in persistence layers or
   exchanged between micro services.  Use `GeometrySerializer.to_export(graph)`
   and `GeometrySerializer.from_export(payload)` for round trips.
3. **CAD export payloads** – generated by `GeometrySerializer.to_cad(graph)`.
   This mirrors the parsed CAD format (point dictionaries) while preserving
   source references and metadata.

All serializers preserve the `SourceReference` metadata so downstream services can
trace every node back to the originating CAD entity.

## Overlay Contracts

`app.core.overlay.merge_graphs(base, overlay)` merges a delta graph into a base
plan.  The overlay can provide full entities or partial updates:

- When the overlay omits a `source` reference, the base reference is preserved.
- Metadata dictionaries are merged, favouring the overlay for conflicting keys.
- New entities and relationships are appended to the base graph.

Import services can therefore ingest CAD payloads, the overlay service can apply
manual annotations or design revisions, and export services can serialize the
result back to neutral JSON or CAD friendly payloads without losing provenance.
